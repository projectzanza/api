require 'rails_helper'

# This spec was generated by rspec-rails when you ran the scaffold generator.
# It demonstrates how one might use RSpec to specify the controller code that
# was generated by Rails when you ran the scaffold generator.
#
# It assumes that the implementation code is generated by the rails scaffold
# generator.  If you are using any extension libraries to generate different
# controller code, this generated spec may or may not pass.
#
# It only uses APIs available in rails and/or rspec-rails.  There are a number
# of tools you can use to make these specs even more expressive, but we're
# sticking to rails and rspec-rails APIs to keep things simple and stable.
#
# Compared to earlier versions of this generator, there is very limited use of
# stubs and message expectations in this spec.  Stubs are only used when there
# is no simpler way to get a handle on the object needed for the example.
# Message expectations are only used when there is no simpler way to specify
# that an instance is receiving a specific message.

RSpec.describe JobsController, type: :controller do
  before(:each) do
    login_user
  end

  describe 'get#index' do
    it 'should return a list of all jobs' do
      3.times { create(:job, user: @user) }

      get :index

      expect(json.length).to eq 3
    end
  end

  describe 'get#show' do
    it 'should return a single job' do
      job = create(:job, user: @user)

      get :show,
          params: { id: job.id }

      expect(json['id']).to eq job.id
    end
  end

  describe 'post#create' do
    it 'should create a job' do
      job_attr = attributes_for(:job)

      post :create,
           params: job_attr

      expect(response).to have_http_status(:created)
      expect(response.body).to have_json_path('id')
      expect(json['title']).to eq job_attr[:title]
      expect(json['text']).to eq job_attr[:text]
      expect(json['user_id']).to eq @user.id
      expect(json['closed_at']).to be_falsey
    end

    it 'should require a title to be created' do
      job_attr = attributes_for(:job)
      job_attr.delete(:title)

      post :create,
           params: job_attr

      expect(response).to have_http_status(:unprocessable_entity)
    end
  end

  describe 'patch#update' do
    it 'should update the job details belonging to a user' do
      job = create(:job, user: @user)
      new_job_attr = attributes_for(:job)

      patch :update,
            params: new_job_attr.merge(id: job.id)

      expect(response).to have_http_status(:ok)
      expect(json['id']).to eq(job.id)
      expect(json['title']).to eq new_job_attr[:title]
      expect(json['text']).to eq new_job_attr[:text]
    end

    it 'should return an error if trying to update another users job' do
      job = create(:job, user: @user)
      # login as a second user
      login_user
      new_job_attr = attributes_for(:job)

      patch :update,
            params: new_job_attr.merge(id: job.id)

      expect(response).to have_http_status(:not_found)
    end
  end

  describe 'delete#destroy' do
    it 'should soft delete the job' do
      job = create(:job, user: @user)

      delete :destroy,
             params: { id: job.id }

      expect { Job.find(job.id) }.to raise_error(ActiveRecord::RecordNotFound)
      expect(Job.only_deleted.find(job.id)).to be_truthy
    end

    it 'should not delete another users job' do
      job = create(:job, user: @user)

      login_user

      delete :destroy,
             params: { id: job.id }

      expect(response).to have_http_status(:not_found)
    end
  end
end
